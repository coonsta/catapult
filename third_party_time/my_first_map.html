<!DOCTYPE html>
<link rel="import" href="/perf_insights/value/value.html">
<link rel="import" href="/perf_insights/map_function.html">
<script>'use strict';

tr.exportTo('pie', function() {
  // General-purpose stuff.

  // FIXME: Replace this with Reflect.ownKeys when V8 implements Reflect.
  function* keys(o) {
    for (var p in o) {
      if (o.hasOwnProperty(p)) {
        yield p;
      }
    }
  }

  // Concatenates two iterators.
  function* concatIterators(xs, ys) {
    yield* xs;
    yield* ys;
  }

  // ('a -> 'b iterator) -> 'a iterator -> 'b iterator
  function lift(f) {
    return function*(xs) {
      for (var x of xs) {
        yield* f(x);
      }
    };
  }

  // FIXME: Remove this when V8 implements Array.prototype.find.
  Array.prototype.find = function(callback) {
    for (var x of this) {
      if (callback(x)) {
        return x;
      }
    }
    return undefined;
  };

  // Web platform stuff.

  function cheesyOrigin(url) {
    var cheesyOriginPattern = /^([^:]+):(\/\/)?([^/]+)/;
    var match = url.match(cheesyOriginPattern);
    return match && match[0];
  }

  // Guesses whether two URLs have the same origin.
  function isSameOrigin(urlA, urlB) {
    var a = cheesyOrigin(urlA)
    var b = cheesyOrigin(urlB);
    if (!a) {
      throw 'failed to cheesily parse "' + urlA + '"';
    }
    if (!b) {
      throw 'failed to cheesily parse "' + urlB + '"';
    }
    return a == b;
  }

  // Performance insights model grovelling stuff.

  // Finds CrRendererMain in model.
  function* mainThreads(model) {
    var count = 0;
    for (var pid in model.processes) {
      var process = model.processes[pid];
      for (var tid in process.threads) {
        var thread = process.threads[tid];
        if (thread.name == 'CrRendererMain') {
          count++;
          yield thread;
        }
      }
    }
    if (!count) {
      throw 'did not find a main thread';
    }
  }

  function topLevelSlices(thread) {
    return thread.sliceGroup.slices.filter(function (s) {
      return s.category == 'toplevel';
    });
  }

  var subslices = lift(function* (slice) {
    yield* slice.subSlices;
  });

  // Hackily finds a frame ID associated with a slice.
  function frameOfSlice(slice) {
    switch (slice.title) {
      case 'EvaluateScript':
      case 'FireAnimationFrame':
      case 'FunctionCall':
      case 'TimerFire':
      case 'XHRLoad':
      case 'XHRReadyStateChange':
      // FIXME: Should layout, paint costs be broken out? Probably.
      case 'Paint':
      case 'UpdateLayerTree':
        return slice.args.data.frame;

      case 'ParseHTML':
      // FIXME: Should layout, paint costs be broken out? Probably.
      case 'Layout':
      case 'UpdateLayoutTree':
        return slice.args.beginData.frame;

      // Not sure about these:
      case 'CommitLoad':
      case 'MarkDOMContent':
      case 'MarkLoad':
      case 'ResourceReceiveResponse':
      case 'ResourceReceivedData':
      case 'ResourceSendRequest':
        // Ignored.
        return null;

      // Not interested in these; graphics:
      case 'LayerTreeHost::DoUpdateLayers': // source_frame_number
      case 'PictureLayer::Update':          // source_frame_number
      case 'ThreadProxy::BeginMainFrame':   // begin_frame_id
        // Ignored.
        return null;

      default:
        break;
    }

    // Sanity check: Look for other things that have a frame hanging
    // around one or two levels in.
    for (var prop in slice.args) {
      var looksLikeAFrame = /[Ff]rame/;
      if (looksLikeAFrame.test(prop)) {
        throw 'found ' + slice.title + ' has frame-y property ' + prop;
      }
      for (var subprop in slice.args[prop]) {
        if (looksLikeAFrame.test(subprop)) {
          throw 'found ' + slice.title + ' has frame-y property ' + prop + '.' + subprop;
        }
      }
    }

    return null;
  }

  // Gets a string that describes a RAILInteractionRecord.
  function kindOfInteraction(o) {
    if (o instanceof tr.e.rail.ResponseInteractionRecord) {
      return 'response';
    }
    if (o instanceof tr.e.rail.IdleInteractionRecord) {
      return 'idle';
    }
    if (o instanceof tr.e.rail.AnimationInteractionRecord) {
      return 'animation';
    }
    if (o instanceof tr.e.rail.LoadInteractionRecord) {
      return 'load';
    }
    return null;
  }

  // This analysis.

  // Finds frame loads and classifies them as same-origin or
  // cross-origin (also known as "third party".) Limitations: This
  // does not handle a frame being navigated and reused; it uses
  // CommitLoad, it does not handle a frame being populated from
  // script.
  function findFrames(model) {
    var mainFrameId;
    var lastUrl;
    var frames = {};
    model.iterateAllEvents(function(event) {
      if (event.title == 'RenderFrameImpl::didCommitProvisionalLoad') {
        lastUrl = event.args.url;
        return;
      }
      if (event.title != 'CommitLoad') {
        return;
      }
      var frameId = event.args.data.frame;
      if (!lastUrl) {
        throw 'encountered a CommitLoad without a preceding ' +
              'RenderFrameImpl::didCommitProvisionalLoad; ' +
              'cannot guess what URL is loaded in frame ' + frameId;
      }
      if (!(frameId in frames)) {
        frames[frameId] = [];
      }
      var framesWithThisId = frames[frameId];
      var lastFrameWithThisId = framesWithThisId.length
            ? framesWithThisId[framesWithThisId.length - 1]
            : null;
      if (lastFrameWithThisId) {
          if (lastUrl == lastFrameWithThisId.url) {
            lastUrl = null;
            return;
          }
          // We divide this frame up into distinct time ranges.
          lastFrameWithThisId.until = event.start;
      }

      var frame = {url: lastUrl};
      lastUrl = null;
      framesWithThisId.push(frame);

      frame.isMainFrame = event.args.data.isMainFrame;
      if (frame.isMainFrame) {
        if (mainFrameId) {
          throw 'found two main frames: ' + mainFrameId + ' and ' +
                event.args.data.frame;
        }
        mainFrameId = event.args.data.frame;
      }
    });

    if (!mainFrameId) {
      throw 'did not find a main frame';
    }

    var mainFrameUrl = frames[mainFrameId].find(function(frame) {
      return frame.isMainFrame;
    }).url;

    for (var id in frames) {
      if (!frames.hasOwnProperty(id)) {
        continue;
      }

      frames[id].forEach(function(frame) {
        frame.isSameOrigin = isSameOrigin(frame.url, mainFrameUrl);
      });
    }

    return new Frames(mainFrameId, mainFrameUrl, frames);
  }

  function Frames(mainFrameId, mainFrameUrl, frames) {
    this.mainFrameId = mainFrameId;
    this.mainFrameUrl = mainFrameUrl;
    this.frames = frames;
  }

  Frames.prototype = Object.create(Object.prototype, {
    find: {
      value: function(id, opt_time) {
        var time = opt_time || 0;
        var xs = this.frames[id];
        if (!xs) {
          return null;
        }
        for (var x of xs) {
          if (!('until' in x) || time < x.until) {
            return x;
          }
        }
        return null;
      }
    }
  });

  function Totals() {
    this.firstParty = 0;
    this.thirdParty = 0;
    this.unaccounted = 0;
    this.firstPartyLabels = {};
    this.thirdPartyLabels = {};
    this.unaccountedLabels = {};
  }

  Totals.prototype = Object.create(Object.prototype, {
    accumulate: {
      value: function(slice, subtotals) {
        // First party
        this.firstParty += subtotals.firstParty;
        this.firstPartyLabels =
          Totals.mergeLabelSets_(this.firstPartyLabels,
                                 subtotals.firstPartyLabels);

        // Third party
        this.thirdParty += subtotals.thirdParty;
        this.thirdPartyLabels =
          Totals.mergeLabelSets_(this.thirdPartyLabels,
                                 subtotals.thirdPartyLabels);

        // Unaccounted
        var unaccounted =
              slice.duration - (subtotals.firstParty + subtotals.thirdParty);
        this.unaccounted += unaccounted;
        if (unaccounted) {
          this.unaccountedLabels[slice.title] = slice.title;
        }
        this.unaccountedLabels =
          Totals.mergeLabelSets_(this.unaccountedLabels,
                                 subtotals.unaccountedLabels);

        return this;
      }
    },

    summarize: {
      value: function() {
        this.firstPartyLabels = Totals.summarizeLabels_(this.firstPartyLabels);
        this.thirdPartyLabels = Totals.summarizeLabels_(this.thirdPartyLabels);
        // Not interested in this for now; it is probably voluminous.
        // this.unaccountedLabels = Totals.summarizeLabels_(this.unaccountedLabels);
        delete this.unaccountedLabels;
        return this;
      }
    }
  });

  Totals.summarizeLabels_ = function(it) {
    var ls = [];
    for (var x in it) {
      ls.push(x);
    }
    ls.sort();
    return ls.join('/');
  };

  Totals.mergeLabelSets_ = function(xs, ys) {
    var zs = {};
    for (var p of concatIterators(keys(xs), keys(ys))) {
      zs[p] = p;
    }
    return zs;
  };

  function bucketTimeInFrames(frames, slice, opt_totals) {
    var totals = opt_totals || new Totals();
    var frameId = frameOfSlice(slice);
    if (!frameId) {
      var subtotals = new Totals();
      slice.subSlices.forEach(function(subSlice) {
        bucketTimeInFrames(frames, subSlice, subtotals);
      });
      totals.accumulate(slice, subtotals);
      return totals;
    }
    var frame = frames.find(frameId, slice.start);
    if (!frame) {
      // FIXME, this happens in every trace, where are these phantom frames
      // coming from?
      totals.unaccounted += slice.duration;
      totals.unaccountedLabels[slice.title] = slice.title;
      return totals;
    }
    // We stop at the outermost frame and attribute all of the time to it.
    if (frame.isSameOrigin) {
      totals.firstParty += slice.duration;
      totals.firstPartyLabels[slice.title] = slice.title;
    } else {
      totals.thirdParty += slice.duration;
      totals.thirdPartyLabels[slice.title] = slice.title;
    }
    return totals;
  }

  function mapper(results, runInfo, model) {
    var frames = findFrames(model);
    results.addValue(new pi.v.DictValue(runInfo, 'frames', frames.frames));

    // Tag events with their RAIL phase
    model.interaction_records
      .filter(function(record) {
        return record instanceof tr.e.rail.RAILInteractionRecord;
      })
      .forEach(function(record) {
        var railKind = kindOfInteraction(record) || 'unknown';
        record.associatedEvents.forEach(function(event) {
          event.railKind = railKind;
        });
      });

    var timeInFramesPerTask = [];
    for (var slice of subslices(lift(topLevelSlices)(mainThreads(model)))) {
      timeInFramesPerTask.push({
        duration: slice.duration,
        origin: cheesyOrigin(frames.mainFrameUrl),
        buckets: bucketTimeInFrames(frames, slice).summarize(),
        kind: slice.railKind || "missing"
      });
    }

    // Ideas for my own buckets:
    // Renderer thread tasks taking >75ms.
    // Events between WebViewImpl::beginFrames.
    // Use RAIL interaction records to group things.
    results.addValue(new pi.v.DictValue(runInfo, 'dataset', {
      timeInFramesPerTask: timeInFramesPerTask
    }));

    // Note to self: if an event is in a RAIL interaction record's
    // associatedEvents, so are all of its descendents.
  }
  pi.MapFunction.register(mapper);
  return null; // No bindings.
});
</script>
