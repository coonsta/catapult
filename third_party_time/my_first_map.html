<!DOCTYPE html>
<link rel="import" href="/perf_insights/value/value.html">
<link rel="import" href="/perf_insights/map_function.html">
<script>'use strict';

tr.exportTo('pie', function() {
  function kind(o) {
    if (o instanceof tr.e.rail.ResponseInteractionRecord) {
      return 'response';
    }
    if (o instanceof tr.e.rail.IdleInteractionRecord) {
      return 'idle';
    }
    if (o instanceof tr.e.rail.AnimationInteractionRecord) {
      return 'animation';
    }
    if (o instanceof tr.e.rail.LoadInteractionRecord) {
      return 'load';
    }
    throw 'no idea what kind of thing this is';
  }

  // Guesses whether two URLs have the same origin.
  function isSameOrigin(urlA, urlB) {
    var cheesyOriginPattern = /^([^:]+):(\/\/)?([^/]+)/;
    var a = urlA.match(cheesyOriginPattern);
    var b = urlB.match(cheesyOriginPattern);
    if (!a) {
      throw 'failed to cheesily parse "' + urlA + '"';
    }
    if (!b) {
      throw 'failed to cheesily parse "' + urlB + '"';
    }
    return a[0] == b[0];
  }

  // Finds frame loads and classifies them as same-origin or
  // cross-origin (also known as "third party".) Limitations: This
  // does not handle a frame being navigated and reused; it uses
  // CommitLoad, it does not handle a frame being populated from
  // script.
  function findFrames(model) {
    var mainFrameId;
    var lastUrl;
    var frames = {};
    model.iterateAllEvents(function(event) {
      if (event.title == 'RenderFrameImpl::didCommitProvisionalLoad') {
        lastUrl = event.args.url;
        return;
      }
      if (event.title != 'CommitLoad') {
        return;
      }
      var frameId = event.args.data.frame;
      if (!lastUrl) {
        throw 'encountered a CommitLoad without a preceding ' +
              'RenderFrameImpl::didCommitProvisionalLoad; ' +
              'cannot guess what URL is loaded in frame ' + frameId;
      }
      if (frameId in frames) {
        if (lastUrl != frames[frameId].url) {
          // TODO: This does happen, and we could handle it by dividing frame
          // IDs up into disjoint time ranges.
          throw 'encountered multiple CommitLoads for ' + frameId + ': "' +
                frames[frameId].url + '" and "' + lastUrl + '"';
        }
        lastUrl = null;
        return;
      }

      var frame = {url: lastUrl};
      lastUrl = null;
      frames[frameId] = frame;

      frame.isMainFrame = event.args.data.isMainFrame;
      if (frame.isMainFrame) {
        if (mainFrameId) {
          throw 'found two main frames: ' + mainFrameId + ' and ' +
                event.args.data.frame;
        }
        mainFrameId = event.args.data.frame;
      }
    });

    if (!mainFrameId) {
      throw 'did not find a main frame';
    }

    var mainFrameUrl = frames[mainFrameId].url;
    for (var id in frames) {
      if (!(frames.hasOwnProperty(id) && frames[id].url)) {
        continue;
      }
      frames[id].isSameOrigin = isSameOrigin(frames[id].url, mainFrameUrl);
    }

    return {
      mainFrameId: mainFrameId,
      frames: frames
    };
  }

  // Finds CrRendererMain in model.
  function* mainThreads(model) {
    var count = 0;
    for (var pid in model.processes) {
      var process = model.processes[pid];
      for (var tid in process.threads) {
        var thread = process.threads[tid];
        if (thread.name == 'CrRendererMain') {
          count++;
          yield thread;
        }
      }
    }
    if (!count) {
      throw 'did not find a main thread';
    }
  }

  function lift(f) {
    return function*(xs) {
      for (var x of xs) {
        yield* f(x);
      }
    };
  }

  function topLevelSlices(thread) {
    return thread.sliceGroup.slices.filter(function (s) {
      return s.category == 'toplevel';
    });
  }

  // Hackily finds a frame ID associated with a slice.
  function findFrame(slice) {
    switch (slice.title) {
      case 'EvaluateScript':
      case 'FireAnimationFrame':
      case 'FunctionCall':
      case 'TimerFire':
      case 'XHRLoad':
      case 'XHRReadyStateChange':
      // FIXME: Should layout, paint costs be broken out? Probably.
      case 'Paint':
      case 'UpdateLayerTree':
        return slice.args.data.frame;

      case 'ParseHTML':
      // FIXME: Should layout, paint costs be broken out? Probably.
      case 'Layout':
      case 'UpdateLayoutTree':
        return slice.args.beginData.frame;

      // Not sure about these:
      case 'CommitLoad':
      case 'MarkDOMContent':
      case 'MarkLoad':
      case 'ResourceReceiveResponse':
      case 'ResourceReceivedData':
      case 'ResourceSendRequest':
        // Ignored.
        return null;

      // Not interested in these; graphics:
      case 'LayerTreeHost::DoUpdateLayers': // source_frame_number
      case 'PictureLayer::Update':          // source_frame_number
      case 'ThreadProxy::BeginMainFrame':   // begin_frame_id
        // Ignored.
        return null;

      default:
        break;
    }

    // Sanity check: Look for other things that have a frame hanging
    // around one or two levels in.
    for (var prop in slice.args) {
      var looksLikeAFrame = /[Ff]rame/;
      if (looksLikeAFrame.test(prop)) {
        throw 'found ' + slice.title + ' has frame-y property ' + prop;
      }
      for (var subprop in slice.args[prop]) {
        if (looksLikeAFrame.test(subprop)) {
          throw 'found ' + slice.title + ' has frame-y property ' + prop + '.' + subprop;
        }
      }
    }

    return null;
  }

  function timeInThirdPartyFrames(frames, slice) {
    var frameId = findFrame(slice);
    if (!frameId) {
      return slice.subSlices.reduce(function(sum, subSlice) {
        return sum + timeInThirdPartyFrames(frames, subSlice);
      }, 0);
    }
    var frame = frames.frames[frameId];
    if (!frame) {
      var frameIds = [];
      for (var f in frames.frames) {
        frameIds.push(f);
      }
      // FIXME, this happens in every trace, where are these phantom frames
      // coming from?
      //throw 'did not find a recorded frame with ID ' + frameId + '; frames are: ' + frameIds.join(', ');
      return 0;
    }
    return frame.isSameOrigin ? 0 : slice.duration;
  }

  function m(results, runInfo, model) {
    var frames = findFrames(model);
    results.addValue(new pi.v.DictValue(runInfo, 'frames', frames));

/*
    var eventHisto = {};
    model.interaction_records
      .filter(function(x) {
        return x instanceof tr.e.rail.RAILInteractionRecord;
      })
      .forEach(function(r) {
        var name = kind(r);
        var count = eventHisto[name] || 0;
        eventHisto[name] = count + 1;

        name += '/' + r.associatedEvents.length;
        count = eventHisto[name] || 0;
        eventHisto[name] = count + 1;
      });
    results.addValue(new pi.v.DictValue(runInfo, 'counts', eventHisto));
*/
    var perTasksTimeInThirdPartyFrames = [];
    for (var slice of lift(topLevelSlices)(mainThreads(model))) {
      perTasksTimeInThirdPartyFrames.push({
        duration: slice.duration,
        thirdPartyDuration: timeInThirdPartyFrames(frames, slice)
      });
    }

    // Ideas for my own buckets:
    // Renderer thread tasks taking >75ms.
    // Events between WebViewImpl::beginFrames.

    // Want to determine:
    // RAIL budget
    // Total time
    // Time in 3rd parties
    var data = [];
    model.interaction_records.forEach(function(record) {
      var datum = {
        kind: kind(record),
        durationMsec: record.duration
      };
      data.push(datum);
    });
    results.addValue(new pi.v.DictValue(runInfo, 'dataset', {
      data: data,
      taskThirdPartyTime: perTasksTimeInThirdPartyFrames
    }));

    // Experimentally, it if an event is in associatedEvents, so are
    // all of its descendents.
  }
  pi.MapFunction.register(m);
  return {
    m: m
  };
});

/*
        Experiment to verify that all descendents appear in a RAIL
        interaction. On a bunch of traces this did not produce any
        'some descendents ...' counts.

        r.associatedEvents.forEach(function(event) {
          event.visited = true;
        });
        r.associatedEvents.forEach(function(event) {
          var nvisited = 0;
          var ndescendents = 0;
          if ('iterateAllDescendents' in event) {
            event.iterateAllDescendents(function(descendent) {
              nvisited += (descendent.visited ? 1 : 0);
              ndescendents++;
            });
          }
          if (ndescendents == 0) {
            name = 'no descendents';
          } else if (!nvisited) {
            name = 'no descendents visited';
          } else if (nvisited == ndescendents) {
            name = 'all descendents visited';
          } else {
            name = 'some descendents visited: ' + nvisited + '/' + ndescendents;
          }
          count = eventHisto[name] || 0;
          eventHisto[name] = count + 1;
        });
*/</script>
